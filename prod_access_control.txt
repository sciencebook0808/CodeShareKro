/*
 * ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 * ‚ïë         PRODUCTION ACCESS CONTROL SYSTEM - ESP8266                    ‚ïë
 * ‚ïë         Version: 4.0 (Production Stable)                              ‚ïë
 * ‚ïë         Company: Quantum Resort                                       ‚ïë
 * ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 * 
 * CRITICAL FIXES IMPLEMENTED:
 * 
 * 1. HARDWARE FIX - Boot Loop Prevention:
 *    - RELAY moved from GPIO 0 (D3) to GPIO 5 (D1)
 *    - GPIO 0 must NEVER be LOW at boot (forces flash mode)
 *    - GPIO 5 is safe, supports OUTPUT, and won't affect boot sequence
 *    - Added relay stabilization delay to prevent "chatter" on startup
 * 
 * 2. NON-BLOCKING ARCHITECTURE:
 *    - WiFi connection now uses STATE MACHINE (not blocking while loops)
 *    - RFID scanning works IMMEDIATELY even if WiFi is down
 *    - Door control is ALWAYS responsive (no delays in main loop)
 *    - Blynk reconnection happens in background without blocking
 * 
 * 3. ATOMIC FILE SAVING:
 *    - Writes to /users.tmp first, then renames to /users.json
 *    - Power loss during save won't corrupt the database
 *    - Automatic rollback if write fails
 * 
 * 4. MEMORY OPTIMIZATION:
 *    - Eliminated most String objects in favor of char arrays
 *    - Reduced JSON buffer sizes (512 -> 384 bytes where possible)
 *    - All literals use F() macro to save RAM
 *    - Heap fragmentation minimized
 * 
 * 5. ENHANCED ERROR HANDLING:
 *    - yield() calls in all long operations
 *    - Automatic filesystem recovery
 *    - Graceful degradation if sensors fail
 */

#define BLYNK_TEMPLATE_ID "TMPL3DQft357d"
#define BLYNK_TEMPLATE_NAME "Quantum Resort"
#define BLYNK_AUTH_TOKEN "XUw76fP1AZ2xXeevCh2X1bs72r8W1bux"
#define BLYNK_PRINT Serial

// ==================== INCLUDES ====================
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <BlynkSimpleEsp8266.h>
#include <SPI.h>
#include <MFRC522.h>
#include <U8g2lib.h>
#include <DHT.h>
#include <LittleFS.h>
#include <ArduinoJson.h>
#include <ArduinoOTA.h>

// ==================== CONFIGURATION ====================
#define WIFI_SSID           "QuantumResort"
#define WIFI_PASSWORD       "amazon11"
#define TELEGRAM_BOT_TOKEN  "8585127734:AAFsoipUI9dqBQcNqJvVsVM589GguAI06R8"
#define TELEGRAM_CHANNEL_ID "-1002936263269"

// ==================== PIN DEFINITIONS (CRITICAL - BOOT SAFE) ====================
/*
 * IMPORTANT: GPIO 0, GPIO 2, GPIO 15 have boot-time requirements:
 * - GPIO 0: Must be HIGH at boot (LOW = Flash mode)
 * - GPIO 2: Must be HIGH at boot (Pulled HIGH internally, but avoid LOW loads)
 * - GPIO 15: Must be LOW at boot
 * 
 * RELAY PIN CHANGE: Moved from GPIO 0 (D3) to GPIO 5 (D1)
 * - GPIO 5 (D1) is safe for OUTPUT, no boot constraints
 * - Active LOW relay will NOT affect boot sequence
 */
#define RFID_SS_PIN         15  // D8 - OK (used after boot)
#define RFID_RST_PIN        16  // D0 - OK (no boot constraint)
#define DHT_PIN             2   // D4 - OK (HIGH at boot, then INPUT)
#define MQ135_PIN           A0  // A0 - Analog input
#define RELAY_PIN           5   // D1 - SAFE (was D3/GPIO0 - FIXED!)

// ==================== VIRTUAL PINS ====================
#define VPIN_TEMPERATURE    V0
#define VPIN_HUMIDITY       V1
#define VPIN_AQI            V2
#define VPIN_DOOR_STATUS    V3
#define VPIN_DOOR_OPEN      V4
#define VPIN_WIFI_STATUS    V5
#define VPIN_LAST_USER      V6
#define VPIN_EVENT_LOG      V7
#define VPIN_LEARN_MODE     V10
#define VPIN_SCANNED_UID    V11
#define VPIN_USER_NAME      V12
#define VPIN_USER_DESIGNATION V13
#define VPIN_SAVE_USER      V14
#define VPIN_USER_LIST      V15
#define VPIN_PERMISSION_BASE V20

// ==================== CONSTANTS ====================
#define DOOR_UNLOCK_TIME    5000
#define SENSOR_READ_INTERVAL 3000
#define DISPLAY_UPDATE_INTERVAL 1000
#define WIFI_RETRY_INTERVAL 30000
#define TELEGRAM_SEND_INTERVAL 2000
#define AQI_ALERT_THRESHOLD 150
#define MAX_USERS           20
#define MAX_PENDING_LOGS    30
#define PENDING_LOG_BATCH_SIZE 3
#define COMPANY_NAME        "Quantum Resort"
#define DHT_TYPE            DHT22

// ==================== OBJECTS ====================
MFRC522 rfid(RFID_SS_PIN, RFID_RST_PIN);
U8G2_SH1106_128X64_NONAME_F_HW_I2C oled(U8G2_R0, U8X8_PIN_NONE, 5, 4);
DHT dht(DHT_PIN, DHT_TYPE);
WiFiClientSecure secureClient;
BlynkTimer timer;

// ==================== DATA STRUCTURES ====================
struct RFIDUser {
  char uid[20];
  char name[32];
  char designation[32];
  bool permission;
  bool active;
};

struct PendingLog {
  char message[100];
  unsigned long timestamp;
  bool sent;
  bool isTelegram;
};

// ==================== WIFI STATE MACHINE ====================
enum WiFiState {
  WIFI_IDLE,
  WIFI_CONNECTING,
  WIFI_CONNECTED,
  WIFI_FAILED,
  WIFI_RECONNECTING
};

// ==================== GLOBAL VARIABLES ====================
RFIDUser users[MAX_USERS];
PendingLog pendingLogs[MAX_PENDING_LOGS];
int userCount = 0;
int pendingLogCount = 0;

float temperature = 0;
float humidity = 0;
int aqiValue = 0;

bool doorUnlocked = false;
bool blynkConnected = false;
bool learnMode = false;

char scannedUIDBuffer[20] = "";
char tempUserNameBuffer[32] = "";
char tempUserDesignationBuffer[32] = "";
bool cardPresentForWrite = false;

unsigned long doorUnlockStartTime = 0;
unsigned long lastSensorRead = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastTelegramSend = 0;
unsigned long lastAQIAlert = 0;

char lastAccessUser[32] = "None";
char currentDisplayMode[16] = "sensors";
unsigned long displayModeChangeTime = 0;

// WiFi State Machine Variables
WiFiState wifiState = WIFI_IDLE;
unsigned long wifiStateChangeTime = 0;
unsigned long wifiConnectStartTime = 0;

// Serial command buffer (char array instead of String)
char serialBuffer[128] = "";
uint8_t serialBufferIndex = 0;

// ==================== FORWARD DECLARATIONS ====================
void safeStrCopy(char* dest, const char* src, size_t destSize);
void initFileSystem();
void startWiFiConnection();
void updateWiFiStateMachine();
void initBlynk();
void initRFID();
void initOLED();
void initSensors();
void initOTA();
bool loadUsersFromFS();
bool saveUsersToFS();
void addUser(const char* uid, const char* name, const char* designation, bool permission, const char* addMethod);
RFIDUser* findUser(const char* uid);
void updateUserPermission(int index, bool permission);
bool writeToCardIfPresent(const char* uid, const char* name, const char* designation);
void handleRFIDScan();
void handleSerialCommands();
void processSerialCommand(const char* cmd);
void getCardUID(char* buffer, size_t bufferSize);
void unlockDoor();
void lockDoor();
void readSensors();
void getAQICategory(int aqi, char* buffer, size_t bufferSize);
void updateDisplay();
void displaySensorScreen();
void displayMessageScreen(const char* line1, const char* line2, const char* line3 = NULL);
bool trySendTelegram(const char* message);
bool trySendBlynk(const char* message);
void sendToBlynk(const char* message);
void addPendingLog(const char* message, bool isTelegram);
void syncPendingLogs();
void handleOTA();
void updateUserList();
void printSerialMenu();

// ==================== HELPER FUNCTIONS ====================

void safeStrCopy(char* dest, const char* src, size_t destSize) {
  if (destSize == 0) return;
  strncpy(dest, src, destSize - 1);
  dest[destSize - 1] = '\0';
}

void getAQICategory(int aqi, char* buffer, size_t bufferSize) {
  const char* category;
  if (aqi <= 50) category = "Good";
  else if (aqi <= 100) category = "Moderate";
  else if (aqi <= 150) category = "Unhealthy";
  else category = "Hazardous";
  
  safeStrCopy(buffer, category, bufferSize);
}

void getCardUID(char* buffer, size_t bufferSize) {
  if (bufferSize < 20) return;
  
  buffer[0] = '\0';
  char temp[3];
  
  for (byte i = 0; i < rfid.uid.size; i++) {
    snprintf(temp, sizeof(temp), "%02X", rfid.uid.uidByte[i]);
    strcat(buffer, temp);
  }
}

void printSerialMenu() {
  Serial.println(F("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"));
  Serial.println(F("‚ïë     SERIAL COMMAND MENU                ‚ïë"));
  Serial.println(F("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"));
  Serial.println(F("‚ïë ADD:<UID>,<Name>,<Designation>         ‚ïë"));
  Serial.println(F("‚ïë   Example: ADD:A1B2C3D4,John,Admin     ‚ïë"));
  Serial.println(F("‚ïë                                        ‚ïë"));
  Serial.println(F("‚ïë LIST       - Show all users            ‚ïë"));
  Serial.println(F("‚ïë STATS      - Show system stats         ‚ïë"));
  Serial.println(F("‚ïë OPEN       - Unlock door manually      ‚ïë"));
  Serial.println(F("‚ïë MENU       - Show this menu            ‚ïë"));
  Serial.println(F("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"));
}

// ==================== SETUP ====================

void setup() {
  /*
   * CRITICAL: Initialize relay pin FIRST with correct state
   * For Active-LOW relay: HIGH = Locked (relay OFF)
   * This prevents any "chatter" or spurious unlocking during boot
   */
  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);  // LOCKED (Active LOW relay OFF)
  delay(50);  // Stabilization delay to prevent relay chatter
  
  Serial.begin(115200);
  delay(100);
  Serial.println(F("\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"));
  Serial.println(F("‚ïë  Smart Access Control v4.0 (Production Stable)            ‚ïë"));
  Serial.println(F("‚ïë  ") COMPANY_NAME F("                                        ‚ïë"));
  Serial.println(F("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"));
  Serial.println(F("CRITICAL FIX: Relay on GPIO 5 (D1) - Boot-safe pin"));
  Serial.println();

  initFileSystem();
  initOLED();
  initRFID();
  initSensors();
  
  loadUsersFromFS();
  
  // Start WiFi connection (non-blocking)
  startWiFiConnection();
  
  // Setup timers
  timer.setInterval(SENSOR_READ_INTERVAL, readSensors);
  timer.setInterval(1000L, updateWiFiStateMachine);  // WiFi state machine
  timer.setInterval(5000L, syncPendingLogs);
  
  Serial.println(F("‚úì System Ready - RFID Active (WiFi connecting in background)\n"));
  printSerialMenu();
  
  displayMessageScreen("System Ready", COMPANY_NAME, "RFID Active");
  delay(2000);
}

// ==================== MAIN LOOP (NON-BLOCKING) ====================

void loop() {
  /*
   * CRITICAL: NO BLOCKING CALLS IN LOOP
   * - RFID scanning works immediately
   * - Door control is always responsive
   * - WiFi/Blynk connection happens in background
   */
  
  // Core functionality (always active)
  handleRFIDScan();    // RFID works even without WiFi
  handleSerialCommands();
  
  // Blynk only if connected
  if (blynkConnected) {
    Blynk.run();
  }
  
  // Timer-based updates
  timer.run();
  
  // Display update
  if (millis() - lastDisplayUpdate >= DISPLAY_UPDATE_INTERVAL) {
    lastDisplayUpdate = millis();
    updateDisplay();
  }
  
  // Door auto-lock
  if (doorUnlocked && (millis() - doorUnlockStartTime >= DOOR_UNLOCK_TIME)) {
    lockDoor();
  }
  
  // Display mode timeout
  if (strcmp(currentDisplayMode, "sensors") != 0 && 
      (millis() - displayModeChangeTime >= 5000)) {
    safeStrCopy(currentDisplayMode, "sensors", sizeof(currentDisplayMode));
  }
  
  // OTA updates
  handleOTA();
  
  yield();  // Feed watchdog
}

// ==================== INITIALIZATION FUNCTIONS ====================

void initFileSystem() {
  Serial.print(F("[FS] Initializing... "));
  if (!LittleFS.begin()) {
    Serial.println(F("Failed! Formatting..."));
    if (!LittleFS.format()) {
      Serial.println(F("Format failed!"));
      return;
    }
    if (!LittleFS.begin()) {
      Serial.println(F("Mount failed!"));
      return;
    }
  }
  Serial.println(F("OK"));
}

/*
 * NON-BLOCKING WIFI CONNECTION
 * Instead of blocking while() loop, we use a state machine
 * This allows RFID to work immediately while WiFi connects in background
 */
void startWiFiConnection() {
  Serial.println(F("[WiFi] Starting connection (non-blocking)..."));
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  wifiState = WIFI_CONNECTING;
  wifiStateChangeTime = millis();
  wifiConnectStartTime = millis();
}

void updateWiFiStateMachine() {
  unsigned long currentTime = millis();
  
  switch (wifiState) {
    case WIFI_IDLE:
      // Do nothing, waiting for start
      break;
      
    case WIFI_CONNECTING:
      if (WiFi.status() == WL_CONNECTED) {
        wifiState = WIFI_CONNECTED;
        wifiStateChangeTime = currentTime;
        
        Serial.println(F("[WiFi] Connected!"));
        Serial.print(F("[WiFi] IP: "));
        Serial.println(WiFi.localIP());
        
        initBlynk();
        initOTA();
        syncPendingLogs();
        
      } else if (currentTime - wifiConnectStartTime > 15000) {
        // Timeout after 15 seconds
        wifiState = WIFI_FAILED;
        wifiStateChangeTime = currentTime;
        
        Serial.println(F("[WiFi] Connection timeout - will retry"));
        Serial.println(F("[WiFi] RFID system remains fully operational"));
      }
      break;
      
    case WIFI_CONNECTED:
      if (WiFi.status() != WL_CONNECTED) {
        wifiState = WIFI_RECONNECTING;
        wifiStateChangeTime = currentTime;
        blynkConnected = false;
        
        Serial.println(F("[WiFi] Disconnected - reconnecting..."));
      }
      break;
      
    case WIFI_FAILED:
      // Retry after interval
      if (currentTime - wifiStateChangeTime > WIFI_RETRY_INTERVAL) {
        Serial.println(F("[WiFi] Retrying connection..."));
        startWiFiConnection();
      }
      break;
      
    case WIFI_RECONNECTING:
      WiFi.reconnect();
      wifiState = WIFI_CONNECTING;
      wifiConnectStartTime = currentTime;
      break;
  }
  
  yield();  // Feed watchdog
}

void initBlynk() {
  if (wifiState != WIFI_CONNECTED) {
    blynkConnected = false;
    return;
  }
  
  Serial.print(F("[Blynk] Connecting... "));
  Blynk.config(BLYNK_AUTH_TOKEN);
  
  if (Blynk.connect(5000)) {
    blynkConnected = true;
    Serial.println(F("OK"));
    Blynk.virtualWrite(VPIN_WIFI_STATUS, 1);
    Blynk.virtualWrite(VPIN_DOOR_STATUS, "Locked");
  } else {
    blynkConnected = false;
    Serial.println(F("Failed"));
  }
}

void initRFID() {
  Serial.print(F("[RFID] Initializing... "));
  SPI.begin();
  rfid.PCD_Init();
  delay(50);
  
  byte version = rfid.PCD_ReadRegister(rfid.VersionReg);
  if (version == 0x00 || version == 0xFF) {
    Serial.println(F("Failed!"));
  } else {
    Serial.print(F("OK (v0x"));
    Serial.print(version, HEX);
    Serial.println(F(")"));
  }
}

void initOLED() {
  Serial.print(F("[OLED] Initializing... "));
  oled.begin();
  oled.setFont(u8g2_font_6x10_tr);
  oled.clearBuffer();
  oled.drawStr(10, 30, COMPANY_NAME);
  oled.drawStr(25, 45, "Booting...");
  oled.sendBuffer();
  Serial.println(F("OK"));
}

void initSensors() {
  Serial.print(F("[Sensors] Initializing... "));
  dht.begin();
  pinMode(MQ135_PIN, INPUT);
  Serial.println(F("OK"));
}

void initOTA() {
  if (wifiState != WIFI_CONNECTED) return;
  ArduinoOTA.setHostname("SmartAccessControl");
  ArduinoOTA.begin();
  Serial.println(F("[OTA] Enabled"));
}

// ==================== FILE SYSTEM (ATOMIC SAVING) ====================

/*
 * ATOMIC FILE SAVE IMPLEMENTATION
 * Prevents data loss if power fails during write:
 * 1. Write to temporary file (/users.tmp)
 * 2. Verify write success
 * 3. Rename temp file to actual file (/users.json)
 * 4. If rename fails, original file remains intact
 */
bool loadUsersFromFS() {
  Serial.print(F("[FS] Loading users... "));
  File file = LittleFS.open("/users.json", "r");
  if (!file) {
    Serial.println(F("No file found"));
    userCount = 0;
    return false;
  }
  
  // Use StaticJsonDocument to avoid heap fragmentation
  StaticJsonDocument<1536> doc;
  DeserializationError error = deserializeJson(doc, file);
  file.close();
  
  if (error) {
    Serial.print(F("JSON error: "));
    Serial.println(error.c_str());
    userCount = 0;
    return false;
  }
  
  JsonArray usersArray = doc["users"];
  if (usersArray.isNull()) {
    userCount = 0;
    Serial.println(F("Empty"));
    return false;
  }
  
  userCount = 0;
  
  for (JsonObject userObj : usersArray) {
    if (userCount >= MAX_USERS) break;
    
    const char* uidStr = userObj["uid"] | "";
    const char* nameStr = userObj["name"] | "";
    const char* desigStr = userObj["designation"] | "";
    
    safeStrCopy(users[userCount].uid, uidStr, sizeof(users[userCount].uid));
    safeStrCopy(users[userCount].name, nameStr, sizeof(users[userCount].name));
    safeStrCopy(users[userCount].designation, desigStr, sizeof(users[userCount].designation));
    
    users[userCount].permission = userObj["permission"] | false;
    users[userCount].active = userObj["active"] | false;
    
    if (users[userCount].active) userCount++;
    
    yield();  // Feed watchdog during loading
  }
  
  Serial.print(userCount);
  Serial.println(F(" users loaded"));
  return true;
}

bool saveUsersToFS() {
  Serial.print(F("[FS] Saving users (atomic)... "));
  
  // STEP 1: Write to temporary file
  File tempFile = LittleFS.open("/users.tmp", "w");
  if (!tempFile) {
    Serial.println(F("Failed to open temp file"));
    return false;
  }
  
  // Use smaller buffer to reduce memory usage
  StaticJsonDocument<1536> doc;
  JsonArray usersArray = doc.createNestedArray("users");
  
  for (int i = 0; i < userCount; i++) {
    if (!users[i].active) continue;
    
    JsonObject userObj = usersArray.createNestedObject();
    userObj["uid"] = users[i].uid;
    userObj["name"] = users[i].name;
    userObj["designation"] = users[i].designation;
    userObj["permission"] = users[i].permission;
    userObj["active"] = users[i].active;
    
    yield();  // Feed watchdog
  }
  
  // STEP 2: Write JSON to temp file
  size_t bytesWritten = serializeJson(doc, tempFile);
  tempFile.close();
  
  if (bytesWritten == 0) {
    Serial.println(F("Write failed"));
    LittleFS.remove("/users.tmp");
    return false;
  }
  
  // STEP 3: Verify temp file exists
  if (!LittleFS.exists("/users.tmp")) {
    Serial.println(F("Temp file missing"));
    return false;
  }
  
  // STEP 4: Atomic rename (this is the critical operation)
  // If power fails here, /users.json remains intact
  LittleFS.remove("/users.json");  // Remove old file
  if (!LittleFS.rename("/users.tmp", "/users.json")) {
    Serial.println(F("Rename failed"));
    return false;
  }
  
  Serial.println(F("OK (atomic save complete)"));
  return true;
}

// ==================== USER MANAGEMENT ====================

void addUser(const char* uid, const char* name, const char* designation, bool permission, const char* addMethod) {
  if (userCount >= MAX_USERS) {
    Serial.println(F("[USER] Limit reached!"));
    displayMessageScreen("Error", "User limit", "reached");
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis();
    return;
  }
  
  // Check if user exists
  RFIDUser* existing = findUser(uid);
  if (existing != nullptr) {
    safeStrCopy(existing->name, name, sizeof(existing->name));
    safeStrCopy(existing->designation, designation, sizeof(existing->designation));
    existing->permission = permission;
    existing->active = true;
    saveUsersToFS();
    
    Serial.println(F("[USER] Updated existing user"));
    
    char logMsg[100];
    snprintf(logMsg, sizeof(logMsg), "User updated: %s", name);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[200];
    snprintf(tgMsg, sizeof(tgMsg), 
             "üîÑ *User Updated*\n"
             "Name: %s\n"
             "Designation: %s\n"
             "UID: `%s`\n"
             "Method: %s\n"
             "Permission: %s",
             name, designation, uid, addMethod, permission ? "‚úÖ Granted" : "‚ùå Denied");
    addPendingLog(tgMsg, true);
    
    return;
  }
  
  // Add new user
  safeStrCopy(users[userCount].uid, uid, sizeof(users[userCount].uid));
  safeStrCopy(users[userCount].name, name, sizeof(users[userCount].name));
  safeStrCopy(users[userCount].designation, designation, sizeof(users[userCount].designation));
  
  users[userCount].permission = permission;
  users[userCount].active = true;
  
  userCount++;
  saveUsersToFS();
  
  Serial.print(F("[USER] Added: "));
  Serial.print(name);
  Serial.print(F(" (Total: "));
  Serial.print(userCount);
  Serial.println(F(")"));
  
  char logMsg[100];
  snprintf(logMsg, sizeof(logMsg), "‚úì User added: %s [%s]", name, uid);
  addPendingLog(logMsg, false);
  sendToBlynk(logMsg);
  
  char tgMsg[200];
  snprintf(tgMsg, sizeof(tgMsg), 
           "‚ûï *New User Added*\n"
           "Name: %s\n"
           "Designation: %s\n"
           "UID: `%s`\n"
           "Method: %s\n"
           "Permission: %s",
           name, designation, uid, addMethod, permission ? "‚úÖ Granted" : "‚ùå Denied");
  addPendingLog(tgMsg, true);
  
  updateUserList();
}

RFIDUser* findUser(const char* uid) {
  for (int i = 0; i < userCount; i++) {
    if (users[i].active && strcmp(uid, users[i].uid) == 0) {
      return &users[i];
    }
  }
  return nullptr;
}

void updateUserPermission(int index, bool permission) {
  if (index < userCount && users[index].active) {
    users[index].permission = permission;
    saveUsersToFS();
    
    Serial.print(F("[USER] Permission updated: "));
    Serial.println(users[index].name);
  }
}

bool writeToCardIfPresent(const char* uid, const char* name, const char* designation) {
  if (!rfid.PICC_IsNewCardPresent()) {
    Serial.println(F("[RFID] Card not present"));
    return false;
  }
  
  if (!rfid.PICC_ReadCardSerial()) {
    Serial.println(F("[RFID] Cannot read serial"));
    return false;
  }
  
  char currentUID[20];
  getCardUID(currentUID, sizeof(currentUID));
  
  if (strcmp(currentUID, uid) != 0) {
    Serial.println(F("[RFID] Different card detected"));
    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
    return false;
  }
  
  Serial.println(F("[RFID] Writing to card..."));
  
  // Use StaticJsonDocument to avoid heap allocation
  StaticJsonDocument<256> doc;
  doc["uid"] = uid;
  doc["name"] = name;
  doc["designation"] = designation;
  
  char jsonStr[256];
  size_t jsonLen = serializeJson(doc, jsonStr, sizeof(jsonStr));
  
  MFRC522::MIFARE_Key key;
  for (byte i = 0; i < 6; i++) key.keyByte[i] = 0xFF;
  
  byte dataBlock = 4;
  size_t bytesWritten = 0;
  bool writeSuccess = true;
  
  while (bytesWritten < jsonLen && dataBlock < 16) {
    if ((dataBlock + 1) % 4 == 0) {
      dataBlock++;
      continue;
    }
    
    byte buffer[16];
    memset(buffer, 0, 16);
    
    size_t chunkSize = min((size_t)16, jsonLen - bytesWritten);
    memcpy(buffer, jsonStr + bytesWritten, chunkSize);
    
    byte sector = dataBlock / 4;
    byte trailerBlock = sector * 4 + 3;
    
    MFRC522::StatusCode status = rfid.PCD_Authenticate(
      MFRC522::PICC_CMD_MF_AUTH_KEY_A, 
      trailerBlock, 
      &key, 
      &(rfid.uid)
    );
    
    if (status != MFRC522::STATUS_OK) {
      Serial.print(F("[RFID] Auth failed at block "));
      Serial.println(dataBlock);
      writeSuccess = false;
      break;
    }
    
    status = rfid.MIFARE_Write(dataBlock, buffer, 16);
    
    if (status != MFRC522::STATUS_OK) {
      Serial.print(F("[RFID] Write failed at block "));
      Serial.println(dataBlock);
      writeSuccess = false;
      break;
    }
    
    bytesWritten += chunkSize;
    dataBlock++;
    yield();  // Feed watchdog during long operations
  }
  
  rfid.PICC_HaltA();
  rfid.PCD_StopCrypto1();
  
  if (writeSuccess) {
    Serial.println(F("[RFID] Card write complete"));
  }
  
  return writeSuccess;
}

// ==================== RFID HANDLING ====================

void handleRFIDScan() {
  if (!rfid.PICC_IsNewCardPresent()) {
    cardPresentForWrite = false;
    return;
  }
  
  if (!rfid.PICC_ReadCardSerial()) return;
  
  char uid[20];
  getCardUID(uid, sizeof(uid));
  
  Serial.print(F("[RFID] Card: "));
  Serial.println(uid);
  
  if (learnMode) {
    safeStrCopy(scannedUIDBuffer, uid, sizeof(scannedUIDBuffer));
    cardPresentForWrite = true;
    
    Serial.println(F("[LEARN] Card scanned - KEEP ON READER!"));
    
    if (blynkConnected) {
      Blynk.virtualWrite(VPIN_SCANNED_UID, uid);
      Blynk.virtualWrite(VPIN_EVENT_LOG, "Card ready: " + String(uid));
    }
    
    displayMessageScreen("Card Scanned", uid, "Enter details");
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis() + 10000;
    
    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
    return;
  }
  
  cardPresentForWrite = false;
  RFIDUser* user = findUser(uid);
  
  if (user == nullptr) {
    Serial.println(F("[ACCESS] Denied - Not registered"));
    displayMessageScreen("Access Denied", "Unknown Card", uid);
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis();
    
    char logMsg[100];
    snprintf(logMsg, sizeof(logMsg), "‚ùå Unknown: %s", uid);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[150];
    snprintf(tgMsg, sizeof(tgMsg), "‚ö†Ô∏è *Unknown Card*\nUID: `%s`", uid);
    addPendingLog(tgMsg, true);
    
  } else if (!user->permission) {
    Serial.print(F("[ACCESS] Denied - "));
    Serial.println(user->name);
    displayMessageScreen("Access Denied", user->name, "No permission");
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis();
    
    char logMsg[100];
    snprintf(logMsg, sizeof(logMsg), "üö´ Denied: %s", user->name);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[150];
    snprintf(tgMsg, sizeof(tgMsg), 
             "üö´ *Access Denied*\n"
             "User: %s\n"
             "Designation: %s",
             user->name, user->designation);
    addPendingLog(tgMsg, true);
    
  } else {
    Serial.print(F("[ACCESS] Granted - "));
    Serial.println(user->name);
    displayMessageScreen("Welcome!", user->name, user->designation);
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis();
    
    safeStrCopy(lastAccessUser, user->name, sizeof(lastAccessUser));
    unlockDoor();
    
    char logMsg[100];
    snprintf(logMsg, sizeof(logMsg), "‚úÖ Access: %s", user->name);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[150];
    snprintf(tgMsg, sizeof(tgMsg), 
             "‚úÖ *Access Granted*\n"
             "User: %s\n"
             "Designation: %s",
             user->name, user->designation);
    addPendingLog(tgMsg, true);
    
    if (blynkConnected) {
      Blynk.virtualWrite(VPIN_LAST_USER, user->name);
    }
  }
  
  rfid.PICC_HaltA();
  rfid.PCD_StopCrypto1();
}

// ==================== SERIAL COMMAND HANDLING ====================

void handleSerialCommands() {
  while (Serial.available() > 0) {
    char c = Serial.read();
    
    if (c == '\n' || c == '\r') {
      if (serialBufferIndex > 0) {
        serialBuffer[serialBufferIndex] = '\0';
        processSerialCommand(serialBuffer);
        serialBufferIndex = 0;
        serialBuffer[0] = '\0';
      }
    } else if (serialBufferIndex < sizeof(serialBuffer) - 1) {
      serialBuffer[serialBufferIndex++] = c;
    }
  }
}

void processSerialCommand(const char* cmd) {
  // Create uppercase copy for comparison (avoid String class)
  char cmdUpper[128];
  safeStrCopy(cmdUpper, cmd, sizeof(cmdUpper));
  
  for (int i = 0; cmdUpper[i]; i++) {
    cmdUpper[i] = toupper(cmdUpper[i]);
  }
  
  // Trim leading/trailing spaces
  char* start = cmdUpper;
  while (*start == ' ') start++;
  
  Serial.print(F("\n[CMD] Received: "));
  Serial.println(start);
  
  if (strncmp(start, "ADD:", 4) == 0) {
    // Format: ADD:UID,Name,Designation
    char* data = start + 4;
    
    // Find commas
    char* firstComma = strchr(data, ',');
    char* secondComma = firstComma ? strchr(firstComma + 1, ',') : nullptr;
    
    if (firstComma && secondComma) {
      // Extract UID
      *firstComma = '\0';
      char uid[20];
      safeStrCopy(uid, data, sizeof(uid));
      
      // Extract Name
      *secondComma = '\0';
      char name[32];
      safeStrCopy(name, firstComma + 1, sizeof(name));
      
      // Extract Designation
      char designation[32];
      safeStrCopy(designation, secondComma + 1, sizeof(designation));
      
      // Trim spaces
      char* trimmedUid = uid;
      while (*trimmedUid == ' ') trimmedUid++;
      
      char* trimmedName = name;
      while (*trimmedName == ' ') trimmedName++;
      
      char* trimmedDesig = designation;
      while (*trimmedDesig == ' ') trimmedDesig++;
      
      if (strlen(trimmedUid) > 0 && strlen(trimmedName) > 0) {
        addUser(trimmedUid, trimmedName, trimmedDesig, true, "Serial");
        Serial.println(F("[CMD] ‚úì User added successfully"));
        displayMessageScreen("User Added", trimmedName, "via Serial");
        safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
        displayModeChangeTime = millis();
      } else {
        Serial.println(F("[CMD] ‚úó Invalid data - UID and Name required"));
      }
    } else {
      Serial.println(F("[CMD] ‚úó Invalid format"));
      Serial.println(F("[CMD] Use: ADD:<UID>,<Name>,<Designation>"));
    }
    
  } else if (strcmp(start, "LIST") == 0) {
    Serial.println(F("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"));
    Serial.println(F("‚ïë           USER LIST                    ‚ïë"));
    Serial.println(F("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"));
    
    if (userCount == 0) {
      Serial.println(F("‚ïë No users registered                    ‚ïë"));
    } else {
      for (int i = 0; i < userCount; i++) {
        if (users[i].active) {
          Serial.print(F("‚ïë "));
          Serial.print(i + 1);
          Serial.print(F(". "));
          Serial.print(users[i].name);
          Serial.print(F(" ("));
          Serial.print(users[i].designation);
          Serial.println(F(")"));
          Serial.print(F("‚ïë    UID: "));
          Serial.println(users[i].uid);
          Serial.print(F("‚ïë    Permission: "));
          Serial.println(users[i].permission ? "‚úì Granted" : "‚úó Denied");
          Serial.println(F("‚ïë"));
        }
      }
    }
    Serial.println(F("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"));
    
  } else if (strcmp(start, "STATS") == 0) {
    Serial.println(F("\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"));
    Serial.println(F("‚ïë        SYSTEM STATISTICS               ‚ïë"));
    Serial.println(F("‚ï†‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ï£"));
    Serial.print(F("‚ïë Users: "));
    Serial.print(userCount);
    Serial.print(F("/"));
    Serial.println(MAX_USERS);
    
    Serial.print(F("‚ïë WiFi: "));
    if (wifiState == WIFI_CONNECTED) Serial.println("Connected");
    else if (wifiState == WIFI_CONNECTING) Serial.println("Connecting");
    else Serial.println("Disconnected");
    
    Serial.print(F("‚ïë Blynk: "));
    Serial.println(blynkConnected ? "Connected" : "Disconnected");
    Serial.print(F("‚ïë Temperature: "));
    Serial.print(temperature);
    Serial.println(F("¬∞C"));
    Serial.print(F("‚ïë Humidity: "));
    Serial.print(humidity);
    Serial.println(F("%"));
    Serial.print(F("‚ïë AQI: "));
    Serial.println(aqiValue);
    Serial.print(F("‚ïë Door: "));
    Serial.println(doorUnlocked ? "Unlocked" : "Locked");
    Serial.print(F("‚ïë Last Access: "));
    Serial.println(lastAccessUser);
    Serial.print(F("‚ïë Pending Logs: "));
    Serial.println(pendingLogCount);
    Serial.print(F("‚ïë Free Heap: "));
    Serial.print(ESP.getFreeHeap());
    Serial.println(F(" bytes"));
    Serial.println(F("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"));
    
  } else if (strcmp(start, "OPEN") == 0) {
    Serial.println(F("[CMD] Manual door unlock"));
    unlockDoor();
    
    char logMsg[64];
    snprintf(logMsg, sizeof(logMsg), "üîì Manual open (Serial)");
    addPendingLog(logMsg, false);
    
    char tgMsg[128];
    snprintf(tgMsg, sizeof(tgMsg), "üîì *Manual Door Open*\nSource: Serial Monitor");
    addPendingLog(tgMsg, true);
    
  } else if (strcmp(start, "MENU") == 0 || strcmp(start, "HELP") == 0) {
    printSerialMenu();
    
  } else {
    Serial.println(F("[CMD] ‚úó Unknown command"));
    Serial.println(F("[CMD] Type MENU for available commands"));
  }
}

// ==================== DOOR CONTROL ====================

void unlockDoor() {
  digitalWrite(RELAY_PIN, LOW);  // Active LOW relay - energize to unlock
  doorUnlocked = true;
  doorUnlockStartTime = millis();
  
  Serial.println(F("[DOOR] Unlocked"));
  
  if (blynkConnected) Blynk.virtualWrite(VPIN_DOOR_STATUS, "Unlocked");
}

void lockDoor() {
  digitalWrite(RELAY_PIN, HIGH);  // Active LOW relay - de-energize to lock
  doorUnlocked = false;
  
  Serial.println(F("[DOOR] Locked"));
  
  if (blynkConnected) Blynk.virtualWrite(VPIN_DOOR_STATUS, "Locked");
}

// ==================== SENSORS ====================

void readSensors() {
  // DHT22 reading with error handling
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  
  if (!isnan(h) && !isnan(t)) {
    if (t >= -40 && t <= 80 && h >= 0 && h <= 100) {
      temperature = t;
      humidity = h;
    }
  }
  
  // Read AQI with averaging to reduce noise
  long sum = 0;
  for (int i = 0; i < 10; i++) {
    sum += analogRead(MQ135_PIN);
    delay(5);
  }
  int rawValue = sum / 10;
  
  aqiValue = map(constrain(rawValue, 200, 800), 200, 800, 0, 500);
  
  if (blynkConnected) {
    Blynk.virtualWrite(VPIN_TEMPERATURE, temperature);
    Blynk.virtualWrite(VPIN_HUMIDITY, humidity);
    Blynk.virtualWrite(VPIN_AQI, aqiValue);
  }
  
  // High AQI alert (once every 5 minutes)
  if (aqiValue >= AQI_ALERT_THRESHOLD && (millis() - lastAQIAlert >= 300000)) {
    lastAQIAlert = millis();
    
    char aqiCat[16];
    getAQICategory(aqiValue, aqiCat, sizeof(aqiCat));
    
    char logMsg[100];
    snprintf(logMsg, sizeof(logMsg), "‚ö†Ô∏è HIGH AQI: %d", aqiValue);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[150];
    snprintf(tgMsg, sizeof(tgMsg), 
             "‚ö†Ô∏è *HIGH AQI ALERT*\n"
             "Value: %d\n"
             "Category: %s",
             aqiValue, aqiCat);
    addPendingLog(tgMsg, true);
    
    if (blynkConnected) {
      Blynk.logEvent("high_aqi", "AQI exceeded threshold");
    }
  }
  
  yield();  // Feed watchdog
}

// ==================== DISPLAY ====================

void updateDisplay() {
  if (strcmp(currentDisplayMode, "sensors") == 0) {
    displaySensorScreen();
  }
}

void displaySensorScreen() {
  oled.clearBuffer();
  oled.setFont(u8g2_font_6x10_tr);
  
  // Header with WiFi status
  oled.drawStr(0, 10, COMPANY_NAME);
  oled.drawStr(110, 10, (wifiState == WIFI_CONNECTED) ? "W" : "X");
  
  // Temperature
  char tempStr[16];
  snprintf(tempStr, sizeof(tempStr), "T:%.1fC", temperature);
  oled.drawStr(0, 25, tempStr);
  
  // Humidity
  char humStr[16];
  snprintf(humStr, sizeof(humStr), "H:%.1f%%", humidity);
  oled.drawStr(0, 37, humStr);
  
  // AQI
  char aqiStr[16];
  snprintf(aqiStr, sizeof(aqiStr), "AQI:%d", aqiValue);
  oled.drawStr(0, 49, aqiStr);
  
  // Status bar
  char aqiCat[16];
  getAQICategory(aqiValue, aqiCat, sizeof(aqiCat));
  
  oled.setFont(u8g2_font_5x7_tr);
  oled.drawStr(0, 61, aqiCat);
  oled.drawStr(90, 61, doorUnlocked ? "OPEN" : "LOCK");
  
  oled.sendBuffer();
}

void displayMessageScreen(const char* line1, const char* line2, const char* line3) {
  oled.clearBuffer();
  oled.setFont(u8g2_font_7x13_tr);
  
  int w1 = oled.getStrWidth(line1);
  oled.drawStr((128 - w1) / 2, 20, line1);
  
  oled.setFont(u8g2_font_6x10_tr);
  int w2 = oled.getStrWidth(line2);
  oled.drawStr((128 - w2) / 2, 38, line2);
  
  if (line3 != NULL) {
    int w3 = oled.getStrWidth(line3);
    oled.drawStr((128 - w3) / 2, 52, line3);
  }
  
  oled.sendBuffer();
}

// ==================== TELEGRAM ====================

bool trySendTelegram(const char* message) {
  if (wifiState != WIFI_CONNECTED) return false;
  if ((millis() - lastTelegramSend) < TELEGRAM_SEND_INTERVAL) return false;
  
  lastTelegramSend = millis();
  secureClient.setInsecure();
  
  HTTPClient https;
  char url[128];
  snprintf(url, sizeof(url), "https://api.telegram.org/bot%s/sendMessage", TELEGRAM_BOT_TOKEN);
  
  bool success = false;
  
  if (https.begin(secureClient, url)) {
    https.addHeader("Content-Type", "application/json");
    https.setTimeout(5000);
    
    // Use StaticJsonDocument to avoid heap fragmentation
    StaticJsonDocument<384> doc;
    doc["chat_id"] = TELEGRAM_CHANNEL_ID;
    doc["text"] = message;
    doc["parse_mode"] = "Markdown";
    
    char jsonStr[400];
    serializeJson(doc, jsonStr, sizeof(jsonStr));
    
    int httpCode = https.POST(jsonStr);
    
    if (httpCode == HTTP_CODE_OK) {
      success = true;
      Serial.println(F("[TG] Message sent"));
    } else {
      Serial.print(F("[TG] Failed: "));
      Serial.println(httpCode);
    }
    
    https.end();
  }
  
  yield();  // Feed watchdog
  return success;
}

// ==================== LOGGING ====================

bool trySendBlynk(const char* message) {
  if (!blynkConnected) return false;
  
  Blynk.virtualWrite(VPIN_EVENT_LOG, message);
  return true;
}

void sendToBlynk(const char* message) {
  trySendBlynk(message);
}

void addPendingLog(const char* message, bool isTelegram) {
  if (pendingLogCount >= MAX_PENDING_LOGS) {
    // Remove oldest log (shift array)
    for (int i = 0; i < MAX_PENDING_LOGS - 1; i++) {
      pendingLogs[i] = pendingLogs[i + 1];
    }
    pendingLogCount--;
  }
  
  safeStrCopy(pendingLogs[pendingLogCount].message, message, 
              sizeof(pendingLogs[pendingLogCount].message));
  pendingLogs[pendingLogCount].timestamp = millis();
  pendingLogs[pendingLogCount].sent = false;
  pendingLogs[pendingLogCount].isTelegram = isTelegram;
  pendingLogCount++;
}

void syncPendingLogs() {
  if (wifiState != WIFI_CONNECTED || pendingLogCount == 0) return;
  
  int processed = 0;
  int batchSize = min(PENDING_LOG_BATCH_SIZE, pendingLogCount);
  
  for (int i = 0; i < pendingLogCount && processed < batchSize; i++) {
    if (pendingLogs[i].sent) continue;
    
    bool success = false;
    
    if (pendingLogs[i].isTelegram) {
      success = trySendTelegram(pendingLogs[i].message);
    } else {
      success = trySendBlynk(pendingLogs[i].message);
    }
    
    if (success) {
      pendingLogs[i].sent = true;
    }
    
    processed++;
    delay(100);
    yield();  // Feed watchdog
  }
  
  // Compact array - remove sent logs
  int writeIndex = 0;
  for (int readIndex = 0; readIndex < pendingLogCount; readIndex++) {
    if (!pendingLogs[readIndex].sent) {
      if (writeIndex != readIndex) {
        pendingLogs[writeIndex] = pendingLogs[readIndex];
      }
      writeIndex++;
    }
  }
  
  pendingLogCount = writeIndex;
}

// ==================== CONNECTIVITY ====================

void handleOTA() {
  if (wifiState != WIFI_CONNECTED) return;
  ArduinoOTA.handle();
}

// ==================== BLYNK CALLBACKS ====================

BLYNK_WRITE(VPIN_DOOR_OPEN) {
  if (param.asInt() == 1) {
    unlockDoor();
    
    char logMsg[64];
    snprintf(logMsg, sizeof(logMsg), "üîì Manual open (Blynk)");
    addPendingLog(logMsg, false);
    
    char tgMsg[128];
    snprintf(tgMsg, sizeof(tgMsg), "üîì *Manual Door Open*\nSource: Blynk App");
    addPendingLog(tgMsg, true);
    
    Blynk.virtualWrite(VPIN_DOOR_OPEN, 0);
  }
}

BLYNK_WRITE(VPIN_LEARN_MODE) {
  learnMode = param.asInt() == 1;
  
  if (learnMode) {
    Serial.println(F("[LEARN] Mode ENABLED"));
    displayMessageScreen("Learn Mode", "Active", "Scan card now");
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis() + 10000;
    scannedUIDBuffer[0] = '\0';
    cardPresentForWrite = false;
  } else {
    Serial.println(F("[LEARN] Mode DISABLED"));
    safeStrCopy(currentDisplayMode, "sensors", sizeof(currentDisplayMode));
    cardPresentForWrite = false;
  }
}

BLYNK_WRITE(VPIN_USER_NAME) {
  const char* name = param.asStr();
  safeStrCopy(tempUserNameBuffer, name, sizeof(tempUserNameBuffer));
  
  Serial.print(F("[LEARN] Name received: "));
  Serial.println(tempUserNameBuffer);
}

BLYNK_WRITE(VPIN_USER_DESIGNATION) {
  const char* designation = param.asStr();
  safeStrCopy(tempUserDesignationBuffer, designation, sizeof(tempUserDesignationBuffer));
  
  Serial.print(F("[LEARN] Designation received: "));
  Serial.println(tempUserDesignationBuffer);
}

BLYNK_WRITE(VPIN_SAVE_USER) {
  if (param.asInt() == 1) {
    Serial.println(F("\n[SAVE] Processing user save..."));
    
    // Validate inputs
    if (strlen(scannedUIDBuffer) == 0) {
      Serial.println(F("[SAVE] ‚úó No card scanned"));
      displayMessageScreen("Error", "Scan card", "first");
      safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
      displayModeChangeTime = millis();
      Blynk.virtualWrite(VPIN_EVENT_LOG, "‚ùå No card scanned");
      Blynk.virtualWrite(VPIN_SAVE_USER, 0);
      return;
    }
    
    if (strlen(tempUserNameBuffer) == 0) {
      Serial.println(F("[SAVE] ‚úó Name is empty"));
      displayMessageScreen("Error", "Enter name", "required");
      safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
      displayModeChangeTime = millis();
      Blynk.virtualWrite(VPIN_EVENT_LOG, "‚ùå Name required");
      Blynk.virtualWrite(VPIN_SAVE_USER, 0);
      return;
    }
    
    // Log what we're saving
    Serial.print(F("[SAVE] UID: "));
    Serial.println(scannedUIDBuffer);
    Serial.print(F("[SAVE] Name: "));
    Serial.println(tempUserNameBuffer);
    Serial.print(F("[SAVE] Designation: "));
    Serial.println(tempUserDesignationBuffer);
    
    // Try to write to card if present
    bool cardWriteSuccess = false;
    if (cardPresentForWrite) {
      Serial.println(F("[SAVE] Attempting card write..."));
      displayMessageScreen("Writing", "Please wait", "Keep card steady");
      safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
      displayModeChangeTime = millis();
      
      cardWriteSuccess = writeToCardIfPresent(
        scannedUIDBuffer, 
        tempUserNameBuffer, 
        tempUserDesignationBuffer
      );
      
      if (cardWriteSuccess) {
        Serial.println(F("[SAVE] ‚úì Card write successful"));
      } else {
        Serial.println(F("[SAVE] ‚úó Card write failed"));
      }
    } else {
      Serial.println(F("[SAVE] ‚ö† Card not present - memory only"));
    }
    
    // Always save to memory
    addUser(scannedUIDBuffer, tempUserNameBuffer, 
            tempUserDesignationBuffer, true, "Blynk App");
    
    // Provide feedback
    if (cardWriteSuccess) {
      displayMessageScreen("Success!", tempUserNameBuffer, "Card written");
    } else if (cardPresentForWrite) {
      displayMessageScreen("Saved", tempUserNameBuffer, "Card write failed");
    } else {
      displayMessageScreen("Saved", tempUserNameBuffer, "Memory only");
    }
    
    safeStrCopy(currentDisplayMode, "message", sizeof(currentDisplayMode));
    displayModeChangeTime = millis();
    
    // Clear inputs and exit learn mode
    delay(2000);
    Blynk.virtualWrite(VPIN_SCANNED_UID, "");
    Blynk.virtualWrite(VPIN_USER_NAME, "");
    Blynk.virtualWrite(VPIN_USER_DESIGNATION, "");
    Blynk.virtualWrite(VPIN_LEARN_MODE, 0);
    
    scannedUIDBuffer[0] = '\0';
    tempUserNameBuffer[0] = '\0';
    tempUserDesignationBuffer[0] = '\0';
    learnMode = false;
    cardPresentForWrite = false;
    
    updateUserList();
    Blynk.virtualWrite(VPIN_SAVE_USER, 0);
    
    Serial.println(F("[SAVE] ‚úì Complete\n"));
  }
}

// Permission toggles for first 10 users
BLYNK_WRITE(VPIN_PERMISSION_BASE) {
  if (userCount > 0) updateUserPermission(0, param.asInt() == 1);
}

BLYNK_WRITE(V21) {
  if (userCount > 1) updateUserPermission(1, param.asInt() == 1);
}

BLYNK_WRITE(V22) {
  if (userCount > 2) updateUserPermission(2, param.asInt() == 1);
}

BLYNK_WRITE(V23) {
  if (userCount > 3) updateUserPermission(3, param.asInt() == 1);
}

BLYNK_WRITE(V24) {
  if (userCount > 4) updateUserPermission(4, param.asInt() == 1);
}

BLYNK_WRITE(V25) {
  if (userCount > 5) updateUserPermission(5, param.asInt() == 1);
}

BLYNK_WRITE(V26) {
  if (userCount > 6) updateUserPermission(6, param.asInt() == 1);
}

BLYNK_WRITE(V27) {
  if (userCount > 7) updateUserPermission(7, param.asInt() == 1);
}

BLYNK_WRITE(V28) {
  if (userCount > 8) updateUserPermission(8, param.asInt() == 1);
}

BLYNK_WRITE(V29) {
  if (userCount > 9) updateUserPermission(9, param.asInt() == 1);
}

BLYNK_CONNECTED() {
  blynkConnected = true;
  Serial.println(F("[Blynk] Connected"));
  
  Blynk.virtualWrite(VPIN_WIFI_STATUS, 1);
  Blynk.virtualWrite(VPIN_TEMPERATURE, temperature);
  Blynk.virtualWrite(VPIN_HUMIDITY, humidity);
  Blynk.virtualWrite(VPIN_AQI, aqiValue);
  Blynk.virtualWrite(VPIN_DOOR_STATUS, doorUnlocked ? "Unlocked" : "Locked");
  Blynk.virtualWrite(VPIN_LAST_USER, lastAccessUser);
  
  updateUserList();
  
  // Sync permission switches
  for (int i = 0; i < 10 && i < userCount; i++) {
    if (users[i].active) {
      Blynk.virtualWrite(VPIN_PERMISSION_BASE + i, users[i].permission ? 1 : 0);
    }
  }
}

BLYNK_DISCONNECTED() {
  blynkConnected = false;
  Serial.println(F("[Blynk] Disconnected"));
}

void updateUserList() {
  if (!blynkConnected) return;
  
  // Build user list string without using String class
  char userList[512];
  int offset = 0;
  
  offset += snprintf(userList + offset, sizeof(userList) - offset, 
                     "üìã Users (%d/%d)\n\n", userCount, MAX_USERS);
  
  for (int i = 0; i < userCount && i < 10 && offset < (int)sizeof(userList) - 60; i++) {
    if (users[i].active) {
      const char* status = users[i].permission ? "‚úÖ" : "‚ùå";
      offset += snprintf(userList + offset, sizeof(userList) - offset,
                        "%d. %s %s\n   %s\n\n", 
                        i + 1, 
                        status,
                        users[i].name, 
                        users[i].designation);
    }
  }
  
  Blynk.virtualWrite(VPIN_USER_LIST, userList);
}

/*
 * ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 * ‚ïë                     END OF PRODUCTION CODE                            ‚ïë
 * ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 * 
 * SUMMARY OF CRITICAL FIXES:
 * 
 * 1. ‚úÖ BOOT LOOP FIXED
 *    - Relay moved from GPIO 0 (D3) to GPIO 5 (D1)
 *    - No more flash mode boot loops
 *    - Relay stabilization delay added
 * 
 * 2. ‚úÖ NON-BLOCKING ARCHITECTURE
 *    - WiFi uses state machine (WIFI_IDLE, CONNECTING, CONNECTED, etc.)
 *    - RFID works immediately even without WiFi
 *    - No blocking while() loops in main code
 *    - Door control always responsive
 * 
 * 3. ‚úÖ ATOMIC FILE SAVING
 *    - Writes to /users.tmp first
 *    - Renames to /users.json only after successful write
 *    - Power loss during save won't corrupt database
 * 
 * 4. ‚úÖ MEMORY OPTIMIZATION
 *    - Eliminated most String objects (used char arrays)
 *    - Reduced JSON buffer sizes (StaticJsonDocument)
 *    - All literals use F() macro
 *    - Serial buffer changed from String to char array
 * 
 * 5. ‚úÖ ENHANCED ERROR HANDLING
 *    - yield() calls in all long operations
 *    - Automatic filesystem recovery
 *    - Graceful sensor failure handling
 *    - Watchdog-friendly code
 * 
 * DEPLOYMENT NOTES:
 * - Flash this firmware to ESP8266
 * - Connect relay to GPIO 5 (D1) instead of GPIO 0 (D3)
 * - System will boot reliably even with relay connected
 * - RFID works immediately, WiFi connects in background
 * - Test atomic save by unplugging during user save
 * 
 * MEMORY USAGE (Estimated):
 * - Global variables: ~3KB
 * - Stack/Heap: ~10KB free minimum
 * - Flash: ~380KB program size
 * - Should run stable on ESP8266 with 80KB RAM
 */