#define BLYNK_TEMPLATE_ID "TMPL3DQft357d"
#define BLYNK_TEMPLATE_NAME "Quantum Resort"
#define BLYNK_AUTH_TOKEN "XUw76fP1AZ2xXeevCh2X1bs72r8W1bux"
#define BLYNK_PRINT Serial

// INCLUDES
#include <ESP8266WiFi.h>
#include <ESP8266HTTPClient.h>
#include <WiFiClientSecure.h>
#include <BlynkSimpleEsp8266.h>
#include <SPI.h>
#include <MFRC522.h>
#include <U8g2lib.h>
#include <DHT.h>
#include <LittleFS.h>
#include <ArduinoJson.h>
#include <ArduinoOTA.h>

// CONFIGURATION

#define WIFI_SSID           "QuantumResort"
#define WIFI_PASSWORD       "amazon11"
#define TELEGRAM_BOT_TOKEN  "8585127734:AAFsoipUI9dqBQcNqJvVsVM589GguAI06R8"
#define TELEGRAM_CHANNEL_ID "-1002936263269"

// Pin Definitions
// FIXED: RFID RST moved to D0 (GPIO16) - safe, no I2C conflict
#define RFID_SS_PIN         15  // D8 (GPIO15)
#define RFID_RST_PIN        16  // D0 (GPIO16) - CHANGED from D1 to avoid I2C conflict
#define DHT_PIN             2   // D4 (GPIO2)
#define MQ135_PIN           A0  // Analog input
#define RELAY_PIN           0   // D3 (GPIO0) - SWAPPED with old RST pin

// Virtual Pins
#define VPIN_TEMPERATURE    V0
#define VPIN_HUMIDITY       V1
#define VPIN_AQI            V2
#define VPIN_DOOR_STATUS    V3
#define VPIN_DOOR_OPEN      V4
#define VPIN_WIFI_STATUS    V5
#define VPIN_LAST_USER      V6
#define VPIN_EVENT_LOG      V7
#define VPIN_LEARN_MODE     V10
#define VPIN_SCANNED_UID    V11
#define VPIN_USER_NAME      V12
#define VPIN_USER_DESIGNATION V13
#define VPIN_SAVE_USER      V14
#define VPIN_USER_LIST      V15
#define VPIN_PERMISSION_BASE V20

// Constants
#define DOOR_UNLOCK_TIME    5000
#define SENSOR_READ_INTERVAL 3000
#define DISPLAY_UPDATE_INTERVAL 1000
#define WIFI_RECONNECT_INTERVAL 30000
#define TELEGRAM_SEND_INTERVAL 2000
#define AQI_ALERT_THRESHOLD 150
#define MAX_USERS           50
#define MAX_PENDING_LOGS    100
#define PENDING_LOG_BATCH_SIZE 5  // FIXED: Process logs in small batches
#define COMPANY_NAME        "Quantum Inovator's"
#define DHT_TYPE            DHT22
#define WIFI_CONNECT_TIMEOUT_MS 15000

// OBJECTS

MFRC522 rfid(RFID_SS_PIN, RFID_RST_PIN);
// FIXED: I2C pins now clear - SCL=D1(GPIO5), SDA=D2(GPIO4)
U8G2_SH1106_128X64_NONAME_F_HW_I2C oled(U8G2_R0, U8X8_PIN_NONE, 5, 4);
DHT dht(DHT_PIN, DHT_TYPE);
WiFiClientSecure secureClient;
BlynkTimer timer;


// DATA STRUCTURES

struct RFIDUser {
  char uid[20];
  char name[32];
  char designation[32];
  char company[32];
  bool permission;
  bool active;
};

struct PendingLog {
  char message[128];
  unsigned long timestamp;
  bool sent;
  bool isTelegram;  // FIXED: Track message type to avoid string parsing
};


// GLOBAL VARIABLES

RFIDUser users[MAX_USERS];
PendingLog pendingLogs[MAX_PENDING_LOGS];
int userCount = 0;
int pendingLogCount = 0;

float temperature = 0;
float humidity = 0;
int aqiValue = 0;
// FIXED: Using char array instead of String for category (reduce heap fragmentation)
char aqiCategory[16] = "Good";

bool doorUnlocked = false;
bool wifiConnected = false;
bool blynkConnected = false;
bool learnMode = false;

String scannedUID = "";
String tempUserName = "";
String tempUserDesignation = "";
bool cardPresentForWrite = false;  // FIXED: Track if card is still present for writing

unsigned long doorUnlockStartTime = 0;
unsigned long lastSensorRead = 0;
unsigned long lastDisplayUpdate = 0;
unsigned long lastWifiCheck = 0;
unsigned long lastTelegramSend = 0;
unsigned long lastAQIAlert = 0;

char lastAccessUser[32] = "None";  // FIXED: char array instead of String
String currentDisplayMode = "sensors";
unsigned long displayModeChangeTime = 0;

// SETUP

void setup() {
  Serial.begin(115200);
  delay(10);
  Serial.println(F("\n\n‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó"));
  Serial.println(F("‚ïë  Smart Access Control v2.1         ‚ïë"));
  Serial.println(F("‚ïë  " COMPANY_NAME "       ‚ïë"));
  Serial.println(F("‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù\n"));

  pinMode(RELAY_PIN, OUTPUT);
  digitalWrite(RELAY_PIN, HIGH);  // HIGH = locked (relay logic may vary)

  initFileSystem();
  initOLED();
  initRFID();
  initSensors();
  initWiFi();
  initBlynk();
  initOTA();
  
  loadUsersFromFS();
  
  timer.setInterval(SENSOR_READ_INTERVAL, readSensors);
  timer.setInterval(WIFI_RECONNECT_INTERVAL, checkWiFiConnection);
  timer.setInterval(3000L, syncPendingLogs);  // FIXED: More frequent but smaller batches
  
  Serial.println(F("‚úì System Ready\n"));
  displayMessageScreen("System Ready", COMPANY_NAME);
  delay(2000);
}


// MAIN LOOP

void loop() {
  if (blynkConnected) Blynk.run();
  timer.run();
  
  handleRFIDScan();
  
  if (millis() - lastDisplayUpdate >= DISPLAY_UPDATE_INTERVAL) {
    lastDisplayUpdate = millis();
    updateDisplay();
  }
  
  if (doorUnlocked && (millis() - doorUnlockStartTime >= DOOR_UNLOCK_TIME)) {
    lockDoor();
  }
  
  handleOTA();
  
  if (currentDisplayMode != "sensors" && (millis() - displayModeChangeTime >= 5000)) {
    currentDisplayMode = "sensors";
  }
  
  yield();
}

// INITIALIZATION FUNCTIONS

void initFileSystem() {
  Serial.print(F("Initializing filesystem... "));
  if (!LittleFS.begin()) {
    Serial.println(F("Failed! Formatting..."));
    if (!LittleFS.format()) {
      Serial.println(F("Format failed!"));
      return;
    }
    if (!LittleFS.begin()) {
      Serial.println(F("Mount after format failed!"));
      return;
    }
  }
  Serial.println(F("OK"));
}

void initWiFi() {
  Serial.print(F("Connecting to WiFi"));
  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);
  
  unsigned long startAttempt = millis();
  while (WiFi.status() != WL_CONNECTED && 
         (millis() - startAttempt) < WIFI_CONNECT_TIMEOUT_MS) {
    delay(500);
    Serial.print(F("."));
    yield();
  }
  
  if (WiFi.status() == WL_CONNECTED) {
    wifiConnected = true;
    Serial.println(F("\n‚úì WiFi Connected"));
    Serial.print(F("IP: "));
    Serial.println(WiFi.localIP());
  } else {
    wifiConnected = false;
    Serial.println(F("\n‚úó WiFi Failed - Offline mode"));
  }
}

void initBlynk() {
  if (!wifiConnected) {
    blynkConnected = false;
    return;
  }
  
  Serial.print(F("Connecting to Blynk... "));
  Blynk.config(BLYNK_AUTH_TOKEN);
  
  if (Blynk.connect(5000)) {
    blynkConnected = true;
    Serial.println(F("OK"));
    Blynk.virtualWrite(VPIN_WIFI_STATUS, 1);
    Blynk.virtualWrite(VPIN_DOOR_STATUS, "Locked");
  } else {
    blynkConnected = false;
    Serial.println(F("Failed"));
  }
}

void initRFID() {
  Serial.print(F("Initializing RFID... "));
  SPI.begin();
  rfid.PCD_Init();
  delay(50);
  
  byte version = rfid.PCD_ReadRegister(rfid.VersionReg);
  if (version == 0x00 || version == 0xFF) {
    Serial.println(F("Failed!"));
  } else {
    Serial.print(F("OK (v"));
    Serial.print(version, HEX);
    Serial.println(F(")"));
  }
}

void initOLED() {
  Serial.print(F("Initializing OLED... "));
  oled.begin();
  oled.setFont(u8g2_font_6x10_tr);
  oled.clearBuffer();
  oled.drawStr(10, 30, COMPANY_NAME);
  oled.drawStr(20, 45, "Booting...");
  oled.sendBuffer();
  Serial.println(F("OK"));
}

void initSensors() {
  Serial.print(F("Initializing sensors... "));
  dht.begin();
  pinMode(MQ135_PIN, INPUT);
  Serial.println(F("OK"));
}

void initOTA() {
  if (!wifiConnected) return;
  ArduinoOTA.setHostname("SmartAccessControl");
  ArduinoOTA.begin();
  Serial.println(F("‚úì OTA Enabled"));
}


// FILE SYSTEM - FIXED: Reduced JSON buffer to 2KB (safe for ESP8266)

void loadUsersFromFS() {
  File file = LittleFS.open("/users.json", "r");
  if (!file) {
    Serial.println(F("No user file found"));
    userCount = 0;
    return;
  }
  
  // FIXED: Reduced from 4096 to 2048 bytes (safer for ESP8266 heap)
  DynamicJsonDocument doc(2048);
  DeserializationError error = deserializeJson(doc, file);
  file.close();
  
  if (error) {
    Serial.print(F("JSON parse error: "));
    Serial.println(error.c_str());
    userCount = 0;
    return;
  }
  
  JsonArray usersArray = doc["users"];
  if (usersArray.isNull()) {
    userCount = 0;
    return;
  }
  
  userCount = 0;
  
  for (JsonObject userObj : usersArray) {
    if (userCount >= MAX_USERS) break;
    
    const char* uidStr = userObj["uid"] | "";
    const char* nameStr = userObj["name"] | "";
    const char* desigStr = userObj["designation"] | "";
    const char* compStr = userObj["company"] | COMPANY_NAME;
    
    // FIXED: Safe string copy with explicit null termination
    safeStrCopy(users[userCount].uid, uidStr, sizeof(users[userCount].uid));
    safeStrCopy(users[userCount].name, nameStr, sizeof(users[userCount].name));
    safeStrCopy(users[userCount].designation, desigStr, sizeof(users[userCount].designation));
    safeStrCopy(users[userCount].company, compStr, sizeof(users[userCount].company));
    
    users[userCount].permission = userObj["permission"] | false;
    users[userCount].active = userObj["active"] | false;
    
    if (users[userCount].active) userCount++;
  }
  
  Serial.print(userCount);
  Serial.println(F(" users loaded"));
}

void saveUsersToFS() {
  // FIXED: Reduced to 2KB
  DynamicJsonDocument doc(2048);
  JsonArray usersArray = doc.createNestedArray("users");
  
  int savedCount = 0;
  for (int i = 0; i < userCount && savedCount < 20; i++) {  // Limit to 20 users for 2KB buffer
    if (!users[i].active) continue;
    
    JsonObject userObj = usersArray.createNestedObject();
    userObj["uid"] = users[i].uid;
    userObj["name"] = users[i].name;
    userObj["designation"] = users[i].designation;
    userObj["company"] = users[i].company;
    userObj["permission"] = users[i].permission;
    userObj["active"] = users[i].active;
    savedCount++;
  }
  
  File file = LittleFS.open("/users.json", "w");
  if (!file) {
    Serial.println(F("Failed to open file for writing"));
    return;
  }
  
  if (serializeJson(doc, file) == 0) {
    Serial.println(F("Failed to write JSON"));
  }
  
  file.close();
}

// FIXED: Safe string copy helper function
void safeStrCopy(char* dest, const char* src, size_t destSize) {
  if (destSize == 0) return;
  strncpy(dest, src, destSize - 1);
  dest[destSize - 1] = '\0';
}


// USER MANAGEMENT

void addUser(const char* uid, const char* name, const char* designation, bool permission) {
  if (userCount >= MAX_USERS) {
    Serial.println(F("User limit reached!"));
    return;
  }
  
  RFIDUser* existing = findUser(uid);
  if (existing != nullptr) {
    // Update existing user
    safeStrCopy(existing->name, name, sizeof(existing->name));
    safeStrCopy(existing->designation, designation, sizeof(existing->designation));
    existing->permission = permission;
    existing->active = true;
    saveUsersToFS();
    Serial.println(F("User updated"));
    return;
  }
  
  // Add new user
  safeStrCopy(users[userCount].uid, uid, sizeof(users[userCount].uid));
  safeStrCopy(users[userCount].name, name, sizeof(users[userCount].name));
  safeStrCopy(users[userCount].designation, designation, sizeof(users[userCount].designation));
  safeStrCopy(users[userCount].company, COMPANY_NAME, sizeof(users[userCount].company));
  
  users[userCount].permission = permission;
  users[userCount].active = true;
  
  userCount++;
  saveUsersToFS();
  
  // FIXED: Using char buffers for log message
  char logMsg[128];
  snprintf(logMsg, sizeof(logMsg), "‚úì User added: %s [%s]", name, uid);
  addPendingLog(logMsg, false);
  sendToBlynk(logMsg);
}

RFIDUser* findUser(const char* uid) {
  for (int i = 0; i < userCount; i++) {
    if (users[i].active && strcmp(uid, users[i].uid) == 0) {
      return &users[i];
    }
  }
  return nullptr;
}

void updateUserPermission(int index, bool permission) {
  if (index < userCount && users[index].active) {
    users[index].permission = permission;
    saveUsersToFS();
  }
}

// FIXED: Write to card ONLY when card is physically present
// This function is now called from BLYNK_WRITE(VPIN_SAVE_USER) only if card is still present
bool writeToCardIfPresent(const char* uid, const char* name, const char* designation) {
  // Check if the card that was scanned is still present
  if (!rfid.PICC_IsNewCardPresent()) {
    Serial.println(F("Card not present - cannot write"));
    return false;
  }
  
  if (!rfid.PICC_ReadCardSerial()) {
    Serial.println(F("Cannot read card serial"));
    return false;
  }
  
  // Verify it's the same card
  char currentUID[20];
  getCardUID(currentUID, sizeof(currentUID));
  
  if (strcmp(currentUID, uid) != 0) {
    Serial.println(F("Different card detected"));
    rfid.PICC_HaltA();
    rfid.PCD_StopCrypto1();
    return false;
  }
  
  Serial.println(F("Card present - writing data..."));
  
  // Create JSON payload
  StaticJsonDocument<256> doc;
  doc["uid"] = uid;
  doc["name"] = name;
  doc["designation"] = designation;
  doc["company"] = COMPANY_NAME;
  
  String jsonStr;
  serializeJson(doc, jsonStr);
  
  MFRC522::MIFARE_Key key;
  for (byte i = 0; i < 6; i++) key.keyByte[i] = 0xFF;
  
  byte dataBlock = 4;  // Start at block 4 (sector 1)
  int jsonLen = jsonStr.length();
  int bytesWritten = 0;
  bool writeSuccess = true;
  
  while (bytesWritten < jsonLen && dataBlock < 16) {
    // Skip trailer blocks
    if ((dataBlock + 1) % 4 == 0) {
      dataBlock++;
      continue;
    }
    
    // FIXED: Clear buffer before writing
    byte buffer[16];
    memset(buffer, 0, 16);
    
    int chunkSize = min(16, jsonLen - bytesWritten);
    memcpy(buffer, jsonStr.c_str() + bytesWritten, chunkSize);
    
    byte sector = dataBlock / 4;
    byte trailerBlock = sector * 4 + 3;
    
    MFRC522::StatusCode status = rfid.PCD_Authenticate(
      MFRC522::PICC_CMD_MF_AUTH_KEY_A, 
      trailerBlock, 
      &key, 
      &(rfid.uid)
    );
    
    if (status != MFRC522::STATUS_OK) {
      Serial.print(F("Auth failed at block "));
      Serial.println(dataBlock);
      writeSuccess = false;
      break;
    }
    
    status = rfid.MIFARE_Write(dataBlock, buffer, 16);
    
    if (status != MFRC522::STATUS_OK) {
      Serial.print(F("Write failed at block "));
      Serial.println(dataBlock);
      writeSuccess = false;
      break;
    }
    
    bytesWritten += chunkSize;
    dataBlock++;
    yield();  // Prevent WDT reset during write
  }
  
  rfid.PICC_HaltA();
  rfid.PCD_StopCrypto1();
  
  if (writeSuccess) {
    Serial.println(F("‚úì Card write complete"));
  }
  
  return writeSuccess;
}


// RFID HANDLING

void handleRFIDScan() {
  if (!rfid.PICC_IsNewCardPresent()) {
    cardPresentForWrite = false;  // Card removed
    return;
  }
  
  if (!rfid.PICC_ReadCardSerial()) return;
  
  char uid[20];
  getCardUID(uid, sizeof(uid));
  
  Serial.print(F("Card detected: "));
  Serial.println(uid);
  
  if (learnMode) {
    scannedUID = String(uid);
    cardPresentForWrite = true;  // FIXED: Mark card as present for writing
    
    if (blynkConnected) Blynk.virtualWrite(VPIN_SCANNED_UID, uid);
    displayMessageScreen("Card Scanned", uid);
    currentDisplayMode = "message";
    displayModeChangeTime = millis();
    Serial.println(F("Learn mode: Card scanned - KEEP CARD ON READER"));
    
    // Don't halt - keep card active for potential write
    return;
  }
  
  cardPresentForWrite = false;
  RFIDUser* user = findUser(uid);
  
  if (user == nullptr) {
    Serial.println(F("‚úó Card not registered"));
    displayMessageScreen("Access Denied", "Not Registered");
    currentDisplayMode = "message";
    displayModeChangeTime = millis();
    
    char logMsg[128];
    snprintf(logMsg, sizeof(logMsg), "‚ö† Unknown card: %s", uid);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[256];
    snprintf(tgMsg, sizeof(tgMsg), "‚ö†Ô∏è *Unknown Card*\nUID: `%s`", uid);
    addPendingLog(tgMsg, true);
    
  } else if (!user->permission) {
    Serial.println(F("‚úó Access denied"));
    displayMessageScreen("Access Denied", user->name);
    currentDisplayMode = "message";
    displayModeChangeTime = millis();
    
    char logMsg[128];
    snprintf(logMsg, sizeof(logMsg), "‚úó Denied: %s", user->name);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[256];
    snprintf(tgMsg, sizeof(tgMsg), "üö´ *Access Denied*\nUser: %s", user->name);
    addPendingLog(tgMsg, true);
    
  } else {
    Serial.println(F("‚úì Access granted"));
    displayMessageScreen("Welcome", user->name);
    currentDisplayMode = "message";
    displayModeChangeTime = millis();
    
    safeStrCopy(lastAccessUser, user->name, sizeof(lastAccessUser));
    unlockDoor();
    
    char logMsg[128];
    snprintf(logMsg, sizeof(logMsg), "‚úì Access: %s (%s)", user->name, user->designation);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[256];
    snprintf(tgMsg, sizeof(tgMsg), "‚úÖ *Access Granted*\nUser: %s\nDesignation: %s", 
             user->name, user->designation);
    addPendingLog(tgMsg, true);
    
    if (blynkConnected) {
      Blynk.virtualWrite(VPIN_LAST_USER, user->name);
    }
  }
  
  rfid.PICC_HaltA();
  rfid.PCD_StopCrypto1();
}

void getCardUID(char* buffer, size_t bufferSize) {
  if (bufferSize < 20) return;
  
  buffer[0] = '\0';
  char temp[3];
  
  for (byte i = 0; i < rfid.uid.size; i++) {
    snprintf(temp, sizeof(temp), "%02X", rfid.uid.uidByte[i]);
    strcat(buffer, temp);
  }
}


// DOOR CONTROL

void unlockDoor() {
  digitalWrite(RELAY_PIN, LOW);  // Adjust based on relay logic
  doorUnlocked = true;
  doorUnlockStartTime = millis();
  
  Serial.println(F("Door unlocked"));
  
  if (blynkConnected) Blynk.virtualWrite(VPIN_DOOR_STATUS, "Unlocked");
}

void lockDoor() {
  digitalWrite(RELAY_PIN, HIGH);  // Adjust based on relay logic
  doorUnlocked = false;
  
  Serial.println(F("Door locked"));
  
  if (blynkConnected) Blynk.virtualWrite(VPIN_DOOR_STATUS, "Locked");
}


// SENSORS

void readSensors() {
  float h = dht.readHumidity();
  float t = dht.readTemperature();
  
  if (!isnan(h) && !isnan(t)) {
    if (t >= -40 && t <= 80 && h >= 0 && h <= 100) {
      temperature = t;
      humidity = h;
    }
  }
  
  // MQ135 averaging
  long sum = 0;
  for (int i = 0; i < 10; i++) {
    sum += analogRead(MQ135_PIN);
    delay(5);
  }
  int rawValue = sum / 10;
  
  aqiValue = map(constrain(rawValue, 200, 800), 200, 800, 0, 500);
  getAQICategory(aqiValue, aqiCategory, sizeof(aqiCategory));
  
  if (blynkConnected) {
    Blynk.virtualWrite(VPIN_TEMPERATURE, temperature);
    Blynk.virtualWrite(VPIN_HUMIDITY, humidity);
    Blynk.virtualWrite(VPIN_AQI, aqiValue);
  }
  
  if (aqiValue >= AQI_ALERT_THRESHOLD && (millis() - lastAQIAlert >= 300000)) {
    lastAQIAlert = millis();
    
    char logMsg[128];
    snprintf(logMsg, sizeof(logMsg), "‚ö† HIGH AQI: %d", aqiValue);
    addPendingLog(logMsg, false);
    sendToBlynk(logMsg);
    
    char tgMsg[256];
    snprintf(tgMsg, sizeof(tgMsg), "‚ö†Ô∏è *HIGH AQI ALERT*\nValue: %d\nCategory: %s", 
             aqiValue, aqiCategory);
    addPendingLog(tgMsg, true);
    
    if (blynkConnected) {
      Blynk.logEvent("high_aqi", "AQI: " + String(aqiValue));
    }
  }
}

void getAQICategory(int aqi, char* buffer, size_t bufferSize) {
  const char* category;
  if (aqi <= 50) category = "Good";
  else if (aqi <= 100) category = "Moderate";
  else if (aqi <= 150) category = "Unhealthy";
  else category = "Hazardous";
  
  safeStrCopy(buffer, category, bufferSize);
}


// DISPLAY

void updateDisplay() {
  if (currentDisplayMode == "sensors") {
    displaySensorScreen();
  }
}

void displaySensorScreen() {
  oled.clearBuffer();
  oled.setFont(u8g2_font_6x10_tr);
  
  oled.drawStr(0, 10, COMPANY_NAME);
  oled.drawStr(110, 10, wifiConnected ? "W" : "X");
  
  char tempStr[16];
  snprintf(tempStr, sizeof(tempStr), "T:%.1fC", temperature);
  oled.drawStr(0, 25, tempStr);
  
  char humStr[16];
  snprintf(humStr, sizeof(humStr), "H:%.1f%%", humidity);
  oled.drawStr(0, 37, humStr);
  
  char aqiStr[16];
  snprintf(aqiStr, sizeof(aqiStr), "AQI:%d", aqiValue);
  oled.drawStr(0, 49, aqiStr);
  
  oled.setFont(u8g2_font_5x7_tr);
  oled.drawStr(0, 61, aqiCategory);
  oled.drawStr(90, 61, doorUnlocked ? "OPEN" : "LOCK");
  
  oled.sendBuffer();
}

void displayMessageScreen(const char* line1, const char* line2) {
  oled.clearBuffer();
  oled.setFont(u8g2_font_10x20_tr);
  
  int w1 = oled.getStrWidth(line1);
  int w2 = oled.getStrWidth(line2);
  
  oled.drawStr((128 - w1) / 2, 25, line1);
  oled.drawStr((128 - w2) / 2, 50, line2);
  
  oled.sendBuffer();
}


// TELEGRAM - Returns success status for retry logic

bool trySendTelegram(const char* message) {
  if (!wifiConnected) return false;
  if ((millis() - lastTelegramSend) < TELEGRAM_SEND_INTERVAL) return false;
  
  lastTelegramSend = millis();
  secureClient.setInsecure();
  
  HTTPClient https;
  String url = "https://api.telegram.org/bot" + String(TELEGRAM_BOT_TOKEN) + "/sendMessage";
  
  bool success = false;
  
  if (https.begin(secureClient, url)) {
    https.addHeader("Content-Type", "application/json");
    
    StaticJsonDocument<512> doc;
    doc["chat_id"] = TELEGRAM_CHANNEL_ID;
    doc["text"] = message;
    doc["parse_mode"] = "Markdown";
    
    String jsonStr;
    serializeJson(doc, jsonStr);
    
    int httpCode = https.POST(jsonStr);
    
    if (httpCode == HTTP_CODE_OK) {
      success = true;
    }
    
    https.end();
  }
  
  return success;
}


// LOGGING - FIXED: Returns bool for success

bool trySendBlynk(const char* message) {
  if (!blynkConnected) return false;
  
  Blynk.virtualWrite(VPIN_EVENT_LOG, message);
  Blynk.logEvent("access_event", message);
  return true;
}

void sendToBlynk(const char* message) {
  trySendBlynk(message);
}

// FIXED: Completely rewritten pending log system
// - No large String arrays (was using MAX_PENDING_LOGS * String = huge memory)
// - Processes in small batches (5-6 per cycle)
// - Only removes logs that were successfully sent
// - Tracks message type (Telegram vs Blynk) without string parsing

void addPendingLog(const char* message, bool isTelegram) {
  if (pendingLogCount >= MAX_PENDING_LOGS) {
    // FIFO: Remove oldest log
    for (int i = 0; i < MAX_PENDING_LOGS - 1; i++) {
      pendingLogs[i] = pendingLogs[i + 1];
    }
    pendingLogCount--;
  }
  
  safeStrCopy(pendingLogs[pendingLogCount].message, message, 
              sizeof(pendingLogs[pendingLogCount].message));
  pendingLogs[pendingLogCount].timestamp = millis();
  pendingLogs[pendingLogCount].sent = false;
  pendingLogs[pendingLogCount].isTelegram = isTelegram;
  pendingLogCount++;
}

void syncPendingLogs() {
  if (!wifiConnected || pendingLogCount == 0) return;
  
  // FIXED: Process small batch to avoid memory issues and WDT resets
  int processed = 0;
  int batchSize = min(PENDING_LOG_BATCH_SIZE, pendingLogCount);
  
  for (int i = 0; i < pendingLogCount && processed < batchSize; i++) {
    if (pendingLogs[i].sent) continue;
    
    bool success = false;
    
    if (pendingLogs[i].isTelegram) {
      success = trySendTelegram(pendingLogs[i].message);
    } else {
      success = trySendBlynk(pendingLogs[i].message);
    }
    
    if (success) {
      pendingLogs[i].sent = true;
    }
    
    processed++;
    delay(100);  // Rate limiting
    yield();
  }
  
  // FIXED: Compact array by removing only successfully sent logs
  int writeIndex = 0;
  for (int readIndex = 0; readIndex < pendingLogCount; readIndex++) {
    if (!pendingLogs[readIndex].sent) {
      if (writeIndex != readIndex) {
        pendingLogs[writeIndex] = pendingLogs[readIndex];
      }
      writeIndex++;
    }
  }
  
  int removedCount = pendingLogCount - writeIndex;
  pendingLogCount = writeIndex;
  
  if (removedCount > 0) {
    Serial.print(F("‚úì Synced "));
    Serial.print(removedCount);
    Serial.println(F(" logs"));
  }
}


// CONNECTIVITY

void checkWiFiConnection() {
  if (WiFi.status() != WL_CONNECTED) {
    if (wifiConnected) {
      Serial.println(F("WiFi disconnected"));
      wifiConnected = false;
      blynkConnected = false;
    }
    
    Serial.print(F("Reconnecting WiFi..."));
    WiFi.reconnect();
    
    unsigned long startAttempt = millis();
    while (WiFi.status() != WL_CONNECTED && 
           (millis() - startAttempt) < 5000) {
      delay(500);
      Serial.print(F("."));
      yield();
    }
    
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println(F(" OK"));
      wifiConnected = true;
      initBlynk();
      syncPendingLogs();
    } else {
      Serial.println(F(" Failed"));
    }
  } else {
    if (!wifiConnected) {
      Serial.println(F("WiFi reconnected"));
      wifiConnected = true;
      initBlynk();
    }
  }
}

void handleOTA() {
  if (!wifiConnected) return;
  ArduinoOTA.handle();
}


// BLYNK CALLBACKS

BLYNK_WRITE(VPIN_DOOR_OPEN) {
  if (param.asInt() == 1) {
    unlockDoor();
    
    char logMsg[64];
    snprintf(logMsg, sizeof(logMsg), "üîì Manual door open");
    addPendingLog(logMsg, false);
    
    char tgMsg[128];
    snprintf(tgMsg, sizeof(tgMsg), "üîì *Manual Open*\nSource: Blynk App");
    addPendingLog(tgMsg, true);
    
    Blynk.virtualWrite(VPIN_DOOR_OPEN, 0);
  }
}

BLYNK_WRITE(VPIN_LEARN_MODE) {
  learnMode = param.asInt() == 1;
  
  if (learnMode) {
    Serial.println(F("‚úì Learn mode ENABLED"));
    displayMessageScreen("Learn Mode", "Scan Card");
    currentDisplayMode = "message";
    displayModeChangeTime = millis();
    scannedUID = "";
    cardPresentForWrite = false;
  } else {
    Serial.println(F("‚úó Learn mode DISABLED"));
    currentDisplayMode = "sensors";
    cardPresentForWrite = false;
  }
}

BLYNK_WRITE(VPIN_USER_NAME) {
  tempUserName = param.asStr();
}

BLYNK_WRITE(VPIN_USER_DESIGNATION) {
  tempUserDesignation = param.asStr();
}

BLYNK_WRITE(VPIN_SAVE_USER) {
  if (param.asInt() == 1) {
    if (scannedUID.length() > 0 && tempUserName.length() > 0) {
      
      // FIXED: Write to card ONLY if still present
      bool cardWriteSuccess = false;
      if (cardPresentForWrite) {
        Serial.println(F("Attempting card write..."));
        cardWriteSuccess = writeToCardIfPresent(
          scannedUID.c_str(), 
          tempUserName.c_str(), 
          tempUserDesignation.c_str()
        );
        
        if (!cardWriteSuccess) {
          Serial.println(F("‚ö† Card write failed - please keep card on reader"));
          displayMessageScreen("Write Failed", "Keep card on reader");
          currentDisplayMode = "message";
          displayModeChangeTime = millis();
          
          // Don't save user if card write failed
          Blynk.virtualWrite(VPIN_SAVE_USER, 0);
          return;
        }
      } else {
        Serial.println(F("‚ö† Card not present - skipping card write"));
      }
      
      // Add user to system memory
      addUser(scannedUID.c_str(), tempUserName.c_str(), 
              tempUserDesignation.c_str(), true);
      
      Serial.print(F("‚úì User saved: "));
      Serial.println(tempUserName);
      
      if (cardWriteSuccess) {
        displayMessageScreen("User Saved", "Card Written");
      } else {
        displayMessageScreen("User Saved", "Memory Only");
      }
      currentDisplayMode = "message";
      displayModeChangeTime = millis();
      
      Blynk.virtualWrite(VPIN_SCANNED_UID, "");
      Blynk.virtualWrite(VPIN_USER_NAME, "");
      Blynk.virtualWrite(VPIN_USER_DESIGNATION, "");
      Blynk.virtualWrite(VPIN_LEARN_MODE, 0);
      
      scannedUID = "";
      tempUserName = "";
      tempUserDesignation = "";
      learnMode = false;
      cardPresentForWrite = false;
      
      updateUserList();
    }
    Blynk.virtualWrite(VPIN_SAVE_USER, 0);
  }
}

BLYNK_WRITE(VPIN_PERMISSION_BASE) {
  if (userCount > 0) updateUserPermission(0, param.asInt() == 1);
}

BLYNK_WRITE(V21) {
  if (userCount > 1) updateUserPermission(1, param.asInt() == 1);
}

BLYNK_WRITE(V22) {
  if (userCount > 2) updateUserPermission(2, param.asInt() == 1);
}

BLYNK_WRITE(V23) {
  if (userCount > 3) updateUserPermission(3, param.asInt() == 1);
}

BLYNK_WRITE(V24) {
  if (userCount > 4) updateUserPermission(4, param.asInt() == 1);
}

BLYNK_WRITE(V25) {
  if (userCount > 5) updateUserPermission(5, param.asInt() == 1);
}

BLYNK_WRITE(V26) {
  if (userCount > 6) updateUserPermission(6, param.asInt() == 1);
}

BLYNK_WRITE(V27) {
  if (userCount > 7) updateUserPermission(7, param.asInt() == 1);
}

BLYNK_WRITE(V28) {
  if (userCount > 8) updateUserPermission(8, param.asInt() == 1);
}

BLYNK_WRITE(V29) {
  if (userCount > 9) updateUserPermission(9, param.asInt() == 1);
}

BLYNK_CONNECTED() {
  blynkConnected = true;
  Serial.println(F("‚úì Blynk reconnected"));
  
  Blynk.virtualWrite(VPIN_WIFI_STATUS, 1);
  Blynk.virtualWrite(VPIN_TEMPERATURE, temperature);
  Blynk.virtualWrite(VPIN_HUMIDITY, humidity);
  Blynk.virtualWrite(VPIN_AQI, aqiValue);
  Blynk.virtualWrite(VPIN_DOOR_STATUS, doorUnlocked ? "Unlocked" : "Locked");
  Blynk.virtualWrite(VPIN_LAST_USER, lastAccessUser);
  
  updateUserList();
  
  for (int i = 0; i < 10 && i < userCount; i++) {
    if (users[i].active) {
      Blynk.virtualWrite(VPIN_PERMISSION_BASE + i, users[i].permission ? 1 : 0);
    }
  }
}

BLYNK_DISCONNECTED() {
  blynkConnected = false;
  Serial.println(F("‚úó Blynk disconnected"));
}

void updateUserList() {
  if (!blynkConnected) return;
  
  // FIXED: Use char buffer instead of String concatenation
  char userList[512];
  int offset = 0;
  
  offset += snprintf(userList + offset, sizeof(userList) - offset, 
                     "Users (%d):\n", userCount);
  
  for (int i = 0; i < userCount && i < 10 && offset < (int)sizeof(userList) - 50; i++) {
    if (users[i].active) {
      offset += snprintf(userList + offset, sizeof(userList) - offset,
                        "%d. %s - %s %s\n", 
                        i + 1, 
                        users[i].name, 
                        users[i].designation,
                        users[i].permission ? "‚úì" : "‚úó");
    }
  }
  
  Blynk.virtualWrite(VPIN_USER_LIST, userList);
}
